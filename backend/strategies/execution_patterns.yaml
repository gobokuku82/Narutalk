# Execution Patterns Configuration
# 워크플로우 실행 패턴 및 전략

execution_patterns:
  version: "1.0.0"
  description: "Multi-agent 시스템 실행 패턴 정의"

# 기본 실행 패턴
basic_patterns:
  sequential:
    name: "순차 실행"
    description: "에이전트를 순서대로 실행"
    characteristics:
      - predictable_flow
      - data_dependency
      - simple_debugging
    use_cases:
      - "단순 질의"
      - "의존성이 있는 작업"
      - "단계별 처리 필요"
    example:
      query: "데이터 검색 후 분석"
      flow: "search → analysis"
      
  parallel:
    name: "병렬 실행"
    description: "여러 에이전트 동시 실행"
    characteristics:
      - high_performance
      - resource_intensive
      - complex_coordination
    use_cases:
      - "독립적인 작업들"
      - "시간 critical한 요청"
      - "다중 소스 집계"
    example:
      query: "여러 소스에서 정보 수집"
      flow: "search || news || internal"
      
  hybrid:
    name: "하이브리드 실행"
    description: "순차와 병렬 조합"
    characteristics:
      - optimized_performance
      - flexible_flow
      - adaptive_execution
    use_cases:
      - "복잡한 워크플로우"
      - "다단계 처리"
      - "조건부 분기"
    example:
      query: "분석 후 맞춤 보고서 생성"
      flow: "(analysis || search) → document"

# 고급 실행 패턴
advanced_patterns:
  map_reduce:
    name: "맵-리듀스 패턴"
    description: "데이터 분산 처리 후 집계"
    stages:
      map:
        description: "데이터를 여러 에이전트에 분산"
        agents: ["multiple_instances"]
        parallelism: "high"
      reduce:
        description: "결과 집계 및 종합"
        agents: ["aggregator"]
        parallelism: "none"
    use_cases:
      - "대량 데이터 처리"
      - "다중 거래처 분석"
      - "전사 통계 생성"
      
  pipeline:
    name: "파이프라인 패턴"
    description: "단계별 데이터 변환"
    stages:
      - extract: "데이터 추출"
      - transform: "데이터 변환"
      - analyze: "데이터 분석"
      - present: "결과 표현"
    characteristics:
      - stream_processing
      - continuous_flow
      - stage_isolation
    use_cases:
      - "실시간 데이터 처리"
      - "ETL 작업"
      - "보고서 자동화"
      
  scatter_gather:
    name: "분산-수집 패턴"
    description: "요청 분산 후 결과 수집"
    phases:
      scatter:
        description: "여러 소스로 요청 분산"
        strategy: "broadcast"
      gather:
        description: "응답 수집 및 정리"
        strategy: "aggregate_with_timeout"
    use_cases:
      - "다중 소스 검색"
      - "의견 수렴"
      - "비교 분석"
      
  circuit_breaker:
    name: "서킷 브레이커 패턴"
    description: "장애 전파 방지"
    states:
      closed:
        description: "정상 작동"
        failure_threshold: 5
      open:
        description: "요청 차단"
        timeout: 30
      half_open:
        description: "제한적 허용"
        test_requests: 3
    use_cases:
      - "외부 API 호출"
      - "불안정한 서비스"
      - "리소스 보호"

# 조건부 실행
conditional_execution:
  branching:
    if_then_else:
      description: "조건에 따른 분기"
      example:
        condition: "result.confidence > 0.8"
        then: "proceed_to_document"
        else: "request_more_info"
        
    switch_case:
      description: "다중 조건 분기"
      example:
        variable: "query_type"
        cases:
          analysis: "route_to_analysis"
          search: "route_to_search"
          document: "route_to_document"
          default: "route_to_search"
          
  loops:
    retry_until_success:
      description: "성공까지 재시도"
      max_attempts: 3
      backoff_strategy: "exponential"
      
    iterate_collection:
      description: "컬렉션 반복 처리"
      parallelism: "configurable"
      batch_size: 10
      
  guards:
    pre_condition:
      description: "실행 전 조건 확인"
      checks:
        - "permission_check"
        - "resource_availability"
        - "data_validation"
        
    post_condition:
      description: "실행 후 조건 확인"
      checks:
        - "result_validation"
        - "quality_check"
        - "compliance_check"

# 에러 처리 패턴
error_handling_patterns:
  retry_pattern:
    strategies:
      simple_retry:
        max_attempts: 3
        delay: 1000  # ms
        
      exponential_backoff:
        initial_delay: 1000
        max_delay: 30000
        multiplier: 2
        
      jittered_backoff:
        base_delay: 1000
        jitter_range: [0, 1000]
        
  fallback_pattern:
    strategies:
      alternative_agent:
        description: "대체 에이전트 사용"
        mapping:
          primary: "alternative"
          
      degraded_service:
        description: "기능 축소 제공"
        features:
          - "cached_results"
          - "simplified_analysis"
          
      default_response:
        description: "기본 응답 제공"
        response: "pre_configured"
        
  compensation_pattern:
    description: "실패 시 보상 트랜잭션"
    strategies:
      rollback:
        description: "이전 상태로 복원"
        
      compensate:
        description: "보상 액션 실행"
        
      pivot:
        description: "대체 경로 실행"

# 최적화 전략
optimization_strategies:
  caching:
    levels:
      query_cache:
        ttl: 300
        key: "query_hash"
        
      result_cache:
        ttl: 3600
        key: "query_agent_combination"
        
      agent_state_cache:
        ttl: 1800
        key: "agent_id_state"
        
  batching:
    strategies:
      time_window:
        window_size: 5000  # ms
        max_batch_size: 20
        
      size_based:
        batch_size: 10
        timeout: 10000
        
  resource_pooling:
    connection_pools:
      database:
        min_size: 5
        max_size: 20
        
      api_clients:
        min_size: 3
        max_size: 10
        
    thread_pools:
      agent_executors:
        core_size: 10
        max_size: 50
        queue_size: 100

# 모니터링 포인트
monitoring_points:
  execution_metrics:
    latency:
      measure_points:
        - "request_received"
        - "agent_started"
        - "agent_completed"
        - "response_sent"
        
    throughput:
      window: 60  # seconds
      unit: "requests_per_second"
      
    error_rate:
      window: 300
      threshold: 0.01
      
  resource_metrics:
    cpu_usage:
      sampling_interval: 1000
      alert_threshold: 0.8
      
    memory_usage:
      sampling_interval: 5000
      alert_threshold: 0.85
      
    queue_depth:
      sampling_interval: 500
      alert_threshold: 100
      
  business_metrics:
    success_rate:
      window: 3600
      target: 0.95
      
    user_satisfaction:
      collection: "per_interaction"
      target: 4.5
      
    response_quality:
      evaluation: "sampling"
      sample_rate: 0.1

# 실행 정책
execution_policies:
  priority_handling:
    levels:
      critical:
        queue: "priority"
        timeout_multiplier: 2
        resource_allocation: 1.5
        
      high:
        queue: "priority"
        timeout_multiplier: 1.5
        resource_allocation: 1.2
        
      normal:
        queue: "standard"
        timeout_multiplier: 1
        resource_allocation: 1
        
      low:
        queue: "background"
        timeout_multiplier: 0.5
        resource_allocation: 0.8
        
  rate_limiting:
    global:
      requests_per_second: 100
      burst_size: 200
      
    per_user:
      requests_per_minute: 20
      daily_limit: 1000
      
    per_agent:
      analysis: 50
      search: 100
      document: 30
      customer: 50
      
  timeout_management:
    global_timeout: 60000  # ms
    
    agent_timeouts:
      analysis: 30000
      search: 20000
      document: 45000
      customer: 25000
      
    timeout_actions:
      warn: 0.8  # 80% of timeout
      interrupt: 0.95
      terminate: 1.0

# 실행 컨텍스트
execution_context:
  propagated_data:
    - user_id
    - session_id
    - trace_id
    - correlation_id
    - priority_level
    
  metadata:
    - request_timestamp
    - source_system
    - client_version
    - feature_flags
    
  security_context:
    - authentication_token
    - authorization_scope
    - encryption_keys
    - audit_requirements

# 워크플로우 템플릿
workflow_templates:
  daily_report:
    name: "일일 실적 보고서"
    schedule: "daily_9am"
    pattern: "pipeline"
    agents: ["analysis", "document"]
    
  customer_visit_prep:
    name: "고객 방문 준비"
    trigger: "manual"
    pattern: "scatter_gather"
    agents: ["customer", "search", "document"]
    
  market_analysis:
    name: "시장 분석"
    trigger: "weekly"
    pattern: "map_reduce"
    agents: ["search", "analysis", "document"]
    
  urgent_response:
    name: "긴급 대응"
    trigger: "event"
    pattern: "parallel"
    agents: ["all_available"]
    priority: "critical"
